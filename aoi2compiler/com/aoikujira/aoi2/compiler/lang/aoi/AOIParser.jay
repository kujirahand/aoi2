%{
// generated by AOIParser.jay

package com.aoikujira.aoi2.compiler.lang.aoi;

import java.io.*;
import com.aoikujira.aoi2.compiler.*;

public class AOIParser extends Parser {
    private AOINodeCreator nc;
%}

%token <void>   EQ, EQEQ, GT, GTEQ, LT, LTEQ, NOT, NOTEQ, OR, AND, SHR, SHL
%token <Token>  INT, NUM, STR, WORD, FUNC, FUNCARG, EOL, ';', ACCESSOR
%token <void>   IF, ELSE, FOR, REPEAT, WHILE, RETURN, GET_VARNAME
%token <void>   LET, AS, LOCAL, BREAK, CONTINUE
%token <void>   ':', CONST, THEN, BEGIN, END, DEF_ACCESSOR
%token <void>   INCLUDE, FOREACH
%type  <ANode>  program, stmts, stmt, stmt_c, expr, expr_list, value, variable, 
                varparam
                let, callfunc, callcfunc, stmt_block,
                if_stmt, if_true, if_false, hash_list, hash_pair,
                array_list,
                for_stmt, repeat_stmt, while_stmt, foreach_stmt
%type  <ANode>  def_func, def_fargs, func_stmts, none, stmt_end, def_local_var, include_stmt
%type  <Token>  def_fhead, def_flib, filename, varprop, funcname
%type  <Token>  '+','-','*','/','%','(',')','{','}','[',']'
%left OR AND
%left GT GTEQ LT LTEQ EQEQ EQ NOTEQ
%left '+' '-' '&'
%left '*' '/' '%'
%left '^'
%left ':' '@'
%right UMINUS
%right NOT

%%
program : stmts { topnode = $1; }
        ;
stmts : stmt_c                    { $$ = $1; }
      | none stmt_end
      | stmts none stmt_end
      | stmts stmt_block
      | stmts stmt_c              { $$ = nc.connect($1,$2); }
      | stmts if_stmt             { $$ = nc.connect($1,$2); }
      | stmts for_stmt            { $$ = nc.connect($1,$2); }
      | stmts while_stmt          { $$ = nc.connect($1,$2); }
      | stmts repeat_stmt         { $$ = nc.connect($1,$2); }
      | stmts foreach_stmt        { $$ = nc.connect($1,$2); }
      ;
stmt_block : BEGIN stmts END        { $$ = $2; }
           ;
stmt_c : stmt stmt_end              { $$ = nc.connect($1, $2); }
       ;
stmt : callfunc                     { $$ = nc.addPOP($1); }
     | def_func
     | include_stmt
     | RETURN                       { $$ = nc.return_node();     }
     | expr RETURN                  { $$ = nc.return_node($1); }
     | BREAK                        { $$ = new ANodeNop(nc.FLAG_BREAK); }
     | CONTINUE                     { $$ = new ANodeNop(nc.FLAG_CONTINUE); }
     | let
     | def_local_var
     | WORD error                   { $$ = nc.nop("error"); nc.error(ErrMsg.UnknownWord + ":" + (String)$1.value); }
     ;

def_local_var : WORD AS LOCAL                 { $$ = nc.localvar($1, null); }
              | WORD AS LOCAL EQ expr         { $$ = nc.localvar($1, $5);   }
              | def_local_var WORD         { $$ = nc.connect($1, nc.localvar($2, null)); }
              | def_local_var WORD EQ expr { $$ = nc.connect($1, nc.localvar($2, $4)); }
              ;

include_stmt: filename INCLUDE { $$ = new ANodeNop("include"); } // check at TokenChecker
            ;

/* -----------------------------------------------------------------------------
 * flow
 * -----------------------------------------------------------------------------
 */
/* if */
if_stmt  : IF expr if_true                  { $$ = nc.if_node($2,$3,null); }
         | IF expr if_true ELSE if_false    { $$ = nc.if_node($2,$3,$5); }
         | IF expr stmt stmt_end            { $$ = nc.if_node($2, $3, null); }
         | IF expr if_true ELSE eol_none if_stmt { $$ = nc.if_node($2, $3, $6); }
         ;
if_true  : BEGIN stmts END { $$ = $2; }
         ;
if_false : BEGIN stmts END { $$ = $2; }
         ;
/* for */
for_stmt    : expr_list FOR BEGIN stmts END { $$ = nc.for_node($1,$4); }   
            ;
repeat_stmt : expr REPEAT BEGIN stmts END   { $$ = nc.repeat_node($1,$4); }   
            ;
/* while */
while_stmt : expr WHILE BEGIN stmts END
            { $$ = nc.while_node($1,$4); }   
            ;

/* foreach */
foreach_stmt : expr FOREACH BEGIN stmts END
             { $$ = nc.foreach_node(null, $1, $4); }
             ;

callfunc    : expr_list FUNC                { $$ = nc.callFunc($2, $1);   }
            | FUNC                          { $$ = nc.callFunc($1, null); }
            ;
callcfunc   : FUNC '(' expr_list ')'        { $$ = nc.callFunc($1, $3); }
            ;
let         : variable EQ expr              { $$ = nc.let($1, $3); }
            | variable EQ callfunc          { $$ = nc.let($1, $3); }
            | variable varprop EQ expr      { $$ = nc.setProperty($1, $2, $4); }
            | CONST variable EQ expr        { $$ = new ANodeNop("const"); } // AOITokenizer + AOITokenChecker Macro
            | ACCESSOR EQ expr              { $$ = nc.setAccessor($1, $3); }
            ;
varprop     : '@' WORD      { $$ = $2; }
            | '@' STR       { $$ = $2; }
            | '@' ACCESSOR  { $$ = $2; }
            ;

expr    : value
        | expr '*' expr         { $$ = nc.expr(ANodeTypes.MUL,  $1, $3); }
        | expr '/' expr         { $$ = nc.expr(ANodeTypes.DIV,  $1, $3); }
        | expr '%' expr         { $$ = nc.expr(ANodeTypes.MOD,  $1, $3); }
        | expr '+' expr         { $$ = nc.expr(ANodeTypes.ADD,  $1, $3); }
        | expr '-' expr         { $$ = nc.expr(ANodeTypes.SUB,  $1, $3); }
        | expr '&' expr         { $$ = nc.expr(ANodeTypes.ADDSTR,$1,$3); }
        | expr '^' expr         { $$ = nc.expr(ANodeTypes.POWER,$1, $3); }
        | expr EQ expr          { $$ = nc.expr(ANodeTypes.EQEQ, $1, $3); } // conflict (let, expr)
        | expr GT    expr       { $$ = nc.expr(ANodeTypes.GT,   $1, $3); }
        | expr GTEQ  expr       { $$ = nc.expr(ANodeTypes.GTEQ, $1, $3); }
        | expr LT    expr       { $$ = nc.expr(ANodeTypes.LT,   $1, $3); }
        | expr LTEQ  expr       { $$ = nc.expr(ANodeTypes.LTEQ, $1, $3); }
        | expr EQEQ  expr       { $$ = nc.expr(ANodeTypes.EQEQ, $1, $3); }
        | expr NOTEQ expr       { $$ = nc.expr(ANodeTypes.NOTEQ,$1, $3); }
        | expr OR  expr         { $$ = nc.expr(ANodeTypes.OR, $1, $3); }
        | expr AND expr         { $$ = nc.expr(ANodeTypes.AND,$1, $3); }
        | NOT expr              { $$ = nc.not($2); }
        | UMINUS value          { $$ = nc.uminus($2); }
        | '(' expr ')'          { $$ = nc.setJosi($2, $3); }
        | '(' callfunc ')'      { $$ = nc.setJosi($2, $3); }
        | callcfunc             { $$ = $1;              }
        | FUNC error            { $$ = nc.nop("error"); nc.error(ErrMsg.UnknownWord + ":" + (String)$1.value); }
        ;
array_list  : expr                     { $$ = nc.array_list_begin($1); }
            | array_list eol_none expr { $$ = nc.array_list_append($1, $3); }
            ;
hash_list   : hash_pair                    { $$ = nc.hash_list_begin($1); }
            | hash_list eol_none hash_pair { $$ = nc.hash_list_append($1, $3); }
            ;
hash_pair   : WORD ':' expr { $$ = nc.hash_list_pair($1, $3); }
            | STR  ':' expr { $$ = nc.hash_list_pair($1, $3); }
            ;
expr_list   : expr                  { $$ = nc.expr_list_top($1); }
            | FUNCARG               { $$ = nc.callFunc($1,null); }
            | expr_list expr        { $$ = nc.expr_list_next($1, $2); }
            | expr_list FUNCARG     { $$ = nc.expr_list_next($1, nc.callFunc($2, $1)); }
            ;
value       : variable
            | NUM                   { $$ = nc.constNum($1); }
            | INT                   { $$ = nc.constInt($1); }
            | STR                   { $$ = nc.constStr($1); }
            | '{' eol_none hash_list eol_none '}'  { $$ = nc.hash_list_end($3); $$ = nc.setJosi((ANode)$$, $5); }
            | '[' eol_none array_list eol_none ']' { $$ = nc.array_list_end($3); $$ = nc.setJosi((ANode)$$, $5); }
            | '[' ']' { $$ = nc.constNull(); $$ = nc.setJosi((ANode)$$, $2); }
            | '{' '}' { $$ = nc.constNull(); $$ = nc.setJosi((ANode)$$, $2); }
            ;
variable    : WORD              { $$ = nc.getVariable($1); }
            | variable varparam { $$ = nc.getHash($1, $2); }
            | variable varprop  { $$ = nc.getProperty($1,$2); }
            | ACCESSOR          { $$ = nc.getAccessor($1); }
            ;
varparam    : '[' expr ']'  { $$ = nc.setJosi($2, $3); }
            | ':' expr      { $$ = $2; }    
            ;

def_func    : def_fhead func_stmts          { $$ = nc.registerFunc($1, $2); }
            | def_fhead EQ def_flib         { $$ = new ANodeNop("def_lib"); }
            | '*' ACCESSOR AS DEF_ACCESSOR LT FUNC GT FUNC { $$ = new ANodeNop("def_varfunc"); }
            | '*' ACCESSOR AS DEF_ACCESSOR GT FUNC LT FUNC { $$ = new ANodeNop("def_varfunc"); }
            ;
def_fhead   : '*' funcname '(' def_fargs ')' { $$ = nc.registerFuncHeader($2); }
            | '*' funcname                   { $$ = nc.registerFuncHeader($2); }
            | '*' funcname '(' ')'           { $$ = nc.registerFuncHeader($2); }
            ;
funcname    : FUNC      { $$ = $1; }
            | FUNCARG   { $$ = $1; }
            ;
def_fargs   : WORD
            | def_fargs WORD
            | def_fargs '|'
            | def_fargs ','
            ;
def_flib    : filename '@' INT
            ;
func_stmts  : BEGIN stmts END { $$ = $2; }
            | none          { $$ = $1; }
            ;
stmt_end    : EOL           { $$ = nc.EOL($1); }
            | ';'           { $$ = nc.EOL($1); }
            ;
eol_none    : /* none */
            | EOL
            ;
none        : /* none */            { $$ = new ANodeNop("none"); }
            ;
filename    : STR
            ;

%%
    public AOIParser(GlobalObject global) {
        super(global);
        nc = new AOINodeCreator(this);
    }
    public Object parse(Scanner scanner) throws AOICException{
        try {
            
            return yyparse((AOIScanner)scanner);
            
        } catch (yyException e) {
            throw new AOICException(scanner.reportCur() + ":" + e);
        } catch (java.io.IOException e) {
            throw new AOICException(scanner.reportCur() + ":" + e);
        }
    }
}
