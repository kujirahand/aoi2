class PhidgetInterfaceKit extends Phidget {	private var numSensors:Number;	private var numInputs:Number;	private var numOutputs:Number;	private var outputStates:Array = new Array();	private var inputStates:Array = new Array();	private var sensorValue:Array = new Array();	private var sensorLastValue:Array = new Array();	private var sensorNormMin:Array = new Array();	private var sensorNormMax:Array = new Array();	private var sensorChangeTrigger:Array = new Array();		//events	public function onInputChange(index:Number, newState:Boolean){}	public function onSensorChange(index:Number, newVal:Number){}		//constructor	public function PhidgetInterfaceKit() {		for(var i=0;i<8;i++) {			sensorChangeTrigger[i]=10;			sensorNormMax[i]=1000;			sensorNormMin[i]=0;			sensorValue[i]=65535;			sensorLastValue[i]=65535;		}	}		//getters and setter	public function GetNumOutputs():Number{		return numOutputs;	}	public function GetNumInputs():Number{		return numInputs;	}	public function GetNumSensors():Number{		return numSensors;	}	public function GetInputState(Index:Number):Boolean{		return inputStates[Index];	}	public function GetOutputState(Index:Number):Boolean{		return outputStates[Index];	}	public function GetSensorValue(Index:Number):Number{		return sensorValue[Index];	}	public function GetSensorNormalizeMinimum(Index:Number):Number{		return sensorNormMin[Index];	}	public function GetSensorNormalizeMaximum(Index:Number):Number{		return sensorNormMax[Index];	}	public function GetSensorChangeTrigger(Index:Number):Number{		return sensorChangeTrigger[Index];	}	public function SetOutputState(Index:Number, newVal:Boolean){		var i=0;		if(newVal) {i=1;}		mySocket.send(Constants.PNET_DATAOUT+","+Index+","+i);		outputStates[Index] = newVal;	}	public function SetSensorNormalizeMinimum(Index:Number, newVal:Number){		sensorNormMin[Index]=newVal;	}	public function SetSensorNormalizeMaximum(Index:Number, newVal:Number){		sensorNormMax[Index]=newVal;	}	public function SetSensorChangeTrigger(Index:Number, newVal:Number){		sensorChangeTrigger[Index]=newVal;	}		//private functions	private function userOnConnect(success) {		if (success) {			mySocket.send(Constants.PNET_OPENPACKET+","+Constants.PHIDDEF_INTERFACEKIT+","+serialNumber);		}	}	private function init(dataArray:Array) {		var spec = parseInt(dataArray[2]);		numInputs = Constants.Phid_Device_Def[spec][4];		numOutputs = Constants.Phid_Device_Def[spec][5];		numSensors = Constants.Phid_Device_Def[spec][3];	}	private function gotData(dataArray:Array) {		var j=0;		for(var i=0;i<numOutputs;i++,j++) {				var temp:Boolean = getBoolean(dataArray[1].substring(j,j+1));			outputStates[i] = temp;		}		for(var i=0;i<numInputs;i++,j++) {			var temp1:Boolean = getBoolean(dataArray[1].substring(j,j+1));			if(temp1!=inputStates[i]) {				onInputChange(i,temp1);			}			inputStates[i] = temp1;		}		for(var i=0;i<numSensors;i++,j+=3) {			var temp2:Number = 0, normSensor:Number=0;			temp2 = parseInt(dataArray[1].substring(j,j+3));			if (temp2 == NaN) {temp2 = 1000;} //probably got a '???' = 1000			normSensor = (temp2 - sensorNormMin[i]) * 1000 / (sensorNormMax[i] - sensorNormMin[i]);			if (normSensor < 0) normSensor = 0;			if (normSensor > 1000) normSensor = 1000;			if((normSensor<=sensorLastValue[i]-sensorChangeTrigger[i] ||			normSensor>=sensorLastValue[i]+sensorChangeTrigger[i])) {				onSensorChange(i, normSensor);				sensorLastValue[i] = normSensor;			}			sensorValue[i] = normSensor;		}	}}