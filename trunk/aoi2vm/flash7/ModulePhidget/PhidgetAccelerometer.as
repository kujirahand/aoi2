class PhidgetAccelerometer extends Phidget {	private var numAxis:Number;	private var axis:Array = new Array();	private var axisChangeTrigger:Array = new Array();	private var axisLastTrigger:Array = new Array();		//events	public function onAccelerationChange(index:Number, acceleration:Number){}		//constructor	public function PhidgetAccelerometer() {		for(var i=0;i<2;i++) {			axis[i]=0;			axisChangeTrigger[i]=0;			axisLastTrigger[i]=0;		}	}	//getters and setters	public function GetNumAxis():Number{		return numAxis;	}	public function GetAcceleration(Index:Number):Number{		return axis[Index];	}	public function GetAccelerationChangeTrigger(Index:Number):Number{		return axisChangeTrigger[Index];	}	public function SetAccelerationChangeTrigger(Index:Number, newVal:Number){		axisChangeTrigger[Index] = newVal;	}		//private functions	private function userOnConnect(success) {		if (success) {			mySocket.send(Constants.PNET_OPENPACKET+","+Constants.PHIDDEF_ACCELEROMETER+","+serialNumber);		}	}	private function init(dataArray:Array) {		var spec = parseInt(dataArray[2]);		numAxis = Constants.Phid_Device_Def[spec][3];	}	private function gotData(dataArray:Array) {		var j=0; 		var normAxis;				for(var i=0;i<numAxis;i++) {			normAxis  = parseFloat(dataArray[1+i]);			if((normAxis<=axisLastTrigger[i]-axisChangeTrigger[i] ||			normAxis>=axisLastTrigger[i]+axisChangeTrigger[i])) {				onAccelerationChange(i, normAxis);				axisLastTrigger[i] = normAxis;			}			axis[i] = normAxis;		}	}}