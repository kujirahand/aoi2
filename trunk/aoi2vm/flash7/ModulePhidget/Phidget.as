class Phidget {	private var attached:Boolean = false;	private var serialNumber:Number = 0;	private var deviceVersion:Number = 0;	private var deviceType:String = "";	private var Host:String = "";	private var Port:Number;	private var ServerID:Number;	private var mySocket;	private var password:String;		public function onAttach(phid:Phidget){}	public function onDetach(phid:Phidget){}	public function onError(desc:String, code:Number){}		private function init(dataArray:Array) {}	private function gotData(dataArray:Array) {}		private function userOnData(src:String) {		var packetType:Number;		var dataArray:Array = src.split(",");		packetType = parseInt(dataArray[0]);		//trace("got data: "+src);		switch (packetType) {		case Constants.PNET_AUTHREQUEST :			var MD5 = new md5();			var hash = MD5.hex_md5(dataArray[1]+password);			ServerID = parseInt(dataArray[2]);			//trace("got to auth request: "+hash);			mySocket.send(Constants.PNET_AUTHREPLY+","+hash);			break;		case Constants.PNET_DEVICESTATE :			switch (parseInt(dataArray[1])) {			case Constants.PNET_OPEN :				deviceType = Constants.Phid_DeviceName[Constants.Phid_Device_Def[parseInt(dataArray[2])][0]];				deviceVersion = parseInt(dataArray[3]);				serialNumber = parseInt(dataArray[4]);				attached = true;				init(dataArray);				//trace("got to pnet_open: "+deviceType+" "+serialNumber+" "+deviceVersion);				onAttach(this);				break;			case Constants.PNET_CLOSED :				Close();				return;			case Constants.PNET_ATTACH :				gotData(dataArray);				break;			case Constants.PNET_DETACH :				gotData(dataArray);				break;			case Constants.PNET_PMOPEN :				init(dataArray);				break;			default :				trace("Got bad device state "+src);			}			break;		case Constants.PNET_DATAIN :			gotData(dataArray);			break;		case Constants.PNET_ERROR :			switch (parseInt(dataArray[1])) {			case Constants.PNET_NODEVICE :				onError(Constants.Phid_ErrorDescriptions[Constants.EPHIDGET_NOTFOUND],Constants.EPHIDGET_NOTFOUND);				return;			case Constants.PNET_AUTHFAILED :				onError(Constants.Phid_ErrorDescriptions[Constants.EPHIDGET_BADPASSWORD],Constants.EPHIDGET_BADPASSWORD);				return;			default :				trace("Got bad error");			}			break;		default :			trace("Got bad packet");		}	}	public function Close() {		onDetach(this);		attached = false;		mySocket.close();	}		//override this in the subclass	private function userOnConnect(success) {}		public function openRemoteIP(ip:String, port:Number, serial:Number, pass:String):Number {		password = pass;		serialNumber = serial;		mySocket = new XMLSocket();		var owner:Phidget = this;		Host=ip;		Port=port;		mySocket.onData = function(src:String) {			owner.userOnData(src);		};		mySocket.onConnect = function(success:Boolean) {			owner.userOnConnect(success);		};		//trace(ip+" : "+port);		if (!mySocket.connect(ip, port)) {			trace("Does the connect fail immediately?");		}		//trace("Now we wait for onConnect to go?");		return 0;	}		public function getSerialNumber():Number {		return serialNumber;	}	public function isAttached():Boolean {		return attached;	}	public function getDeviceVersion():Number {		return deviceVersion;	}	public function getDeviceType():String {		return deviceType;	}		public function getServerAddress():String {		return Host;	}		public function getServerPort():Number {		return Port;	}	public function getServerID():Number {		return ServerID;	}	public function setDeviceType(string:String) {		deviceType = string;	}	public function setDeviceVersion(i:Number) {		deviceVersion = i;	}	public function setSerialNumber(i:Number) {		serialNumber = i;	}		private function getBoolean(data:String):Boolean {		if (data == "?") {			return false;		}		if (data == "1") {			return true;		}		if (data == "0") {			return false;		}		return false;	}}