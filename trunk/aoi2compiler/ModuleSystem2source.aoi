#!/usr/local/bin/aoi
<?bas

modname = "ModuleSystem"
headfile = modname & ".aoi2"
s = file_load(headfile)
source = s
str_getToken!(s, "<function>")
dat = str_getToken!(s, "</function>")
dim uniqno

dat_ary = str_split(dat, "\n")

s = ""
t = ""
cmdtxt = "+system\n"
bastxt = "' {modname}.bas generated by {modname}.aoi2\n"
astxt  = ""
astxt2 = ""

for line in dat_ary
  def_ary = str_split(line, "#")
  d_def  = def_ary[0]
  d_func = str_trim(def_ary[1])
  d_desc = str_trim(def_ary[2])
  #
  f_str = d_def
  d_def = str_getToken!(f_str,"=")
  str_getToken!(f_str,`"`)
  f_mod = str_getToken!(f_str,`"`)
  str_getToken!(f_str,`@`)
  f_no = str_trim(f_str)
  f_str = d_def
  f_name = str_getToken!(f_str,"(")
  f_arg  = str_getToken!(f_str,")")
  #
  if f_mod = "" then
    s = s & "        // " & line & "\n"
    str_delete!(line, 1, 2)
    if line="" then continue
    cmdtxt = cmdtxt & <qq>-{line}\n</qq>
    continue
  end if
  
  str_delete!(f_name,1,1)
  # --- cmdtxt
  cmdtxt = cmdtxt & <qq>|{f_name},"{f_arg}","{d_desc}",{f_no},{d_func},命令\n</qq>
  
  if uniqno[f_no] = true then
    continue
  end
  uniqno[f_no] = true
  s = s & <qq>        case {f_no}: {modname}.{d_func}(arg); break;
</qq>
  if h[d_func] = "" then
    sss = <qq>    // {d_def} # {d_desc}
    public static void {d_func}(AFunctionArg arg) \{
    \}
</qq>
    h[d_func] = sss
    t = t & sss
  end
  # --- bastxt
  a = f_arg
  a = str_getToken(a,"|")
  josilist = ["について","として","から","まで","を","の","が","に","と","へ"]
  for b in josilist
    a = str_replace(a, b, ",")
  next
  if str_mid(a,str_len(a),1) = "," then str_delete!(a, str_len(a), 1)
  if a <> "" then a = "(" & a & ")"
  arg = a
  bastxt = bastxt & <qq>function {d_func}{arg}="{f_mod}"@{f_no}\n</qq>
  # --- astxt
  astxt  = astxt  & <qq>    // {d_def} # {d_desc}\n    public static function {d_func}(arg:ModuleFunctionArg) \{\n       //todo:{d_func}\n    \}\n</qq>
  astxt2 = astxt2 & <qq>        ftable[{f_no}] = {modname}Function.{d_func};\n</qq>
next

ss = <qq>
package aoivm.java;

class {modname}Function
\{
    //--- function table
    public static void call(int id, AFunctionArg arg) \{
      switch (id) \{
{s}
      \}
    \}
\}
//--- function body
/*
{t}
*/
</qq>

#--------------------------------------------
cmdtxt = cmdtxt & <qq>+maro-function\n</qq>
sss = source
str_getToken!(sss, "<sub-function>")
dat = str_getToken!(sss, "</sub-function>")
dat_ary = str_split(dat, "\n")
for line in dat_ary
  c = str_mid(line,1,2)
  if c = "#+" then
    str_delete!(line,1,2)
    cmdtxt = cmdtxt & <qq>-{line}\n</qq>
    continue
  end
  c = str_mid(line,1,1)
  if c = "●" then
    f_str = line
    str_delete!(f_str,1,1)
    f_name = str_getToken!(f_str,"(")
    f_arg  = str_getToken!(f_str,")")
    cmdtxt = cmdtxt & <qq>|{f_name},"{f_arg}"\n</qq>
  end
next


sss = source
str_getToken!(sss, "<basic-function>")
dat = str_getToken!(sss, "</basic-function>")
bastxt = bastxt & "\n' ---\n" & dat & "\n" 

#--------------------------------------------------
# astxt

astxt = <qq>
/**
 * {modname}Table.as generated by {modname}.aoi2
 */
class {modname}Table
\{
    function {modname}Table() \{\} // constructor
    //--- function table
    static function initTable(ftable:Array) \{
{astxt2}
    \}
\}

/* -- template --
{astxt}
*/

</qq>

#-------------------------------------------------
print astxt
//print bastxt

file_save("{modname}Function.java", ss)
file_save("command-{modname}.txt",cmdtxt)
//file_save("{modname}.bas",bastxt)
file_save("{modname}Table.as",astxt)

?>

